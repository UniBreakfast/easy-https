import * as childProcess from 'child_process';
import fs from 'fs';
import path from 'path';
import tempDir from 'temp-dir';

const ETC_HOSTS_LOCALHOST = '127.0.0.1';

// Command required to add domain entry to system hosts
const hostileCmdPath = path.resolve(
  __dirname,
  '..',
  './node_modules/hostile/bin/cmd.js',
);

const tempDirPath = path.resolve(tempDir, 'easy-https');

// Content we will keep in temp files to inform that domain is registered.
const TEMP_FILE_REGISTERED_FLAG_CONTENT = 'true';

function ensureDomainEntryTempFile(domainPointer: string) {
  fs.mkdirSync(tempDirPath, { recursive: true });

  const filePath = path.resolve(tempDirPath, domainPointer + '.data');

  if (fs.existsSync(filePath)) {
    return filePath;
  }

  // Create empty file for this domain pointer
  fs.writeFileSync(filePath, '');

  return filePath;
}

function isDomainEntryRegistered(fullDomain: string) {
  const filePath = ensureDomainEntryTempFile(fullDomain);

  return (
    fs.readFileSync(filePath).toString() === TEMP_FILE_REGISTERED_FLAG_CONTENT
  );
}

function registerDomainEntry(domainPointer: string) {
  const filePath = ensureDomainEntryTempFile(domainPointer);

  return fs.writeFileSync(filePath, TEMP_FILE_REGISTERED_FLAG_CONTENT);
}

function isSubdomainRegistered(subdomain: string, domain: string) {
  return isDomainEntryRegistered(`${subdomain}.${domain}`);
}

export function isDomainsRegistrationRequired(
  domain: string,
  subdomains: string[],
) {
  if (!isDomainEntryRegistered(domain)) {
    return true;
  }

  if (
    subdomains.some(subdomain => {
      return !isSubdomainRegistered(subdomain, domain);
    })
  ) {
    return true;
  }

  return false;
}

export async function addSingleDomainAlias(
  fullDomain: string,
  logger = console.info,
) {
  // Run hostile with sudo. Will ask for user password.
  const domainProcess = childProcess.spawn('sudo', [
    'node',
    hostileCmdPath,
    'set',
    ETC_HOSTS_LOCALHOST,
    fullDomain,
  ]);

  // Show all logs generated by hostile.
  domainProcess.stdout.on('data', data => {
    logger(data.toString().trim());
  });

  return new Promise<void>((resolve, reject) => {
    domainProcess.on('exit', code => {
      if (code === 0) {
        // If we were able to register domain - save it in temp file so we don't have to do it again.
        registerDomainEntry(fullDomain);

        resolve();
      }

      reject();
    });
  });
}

export async function addDomainAliases(
  domain: string,
  subdomains: string[] = [],
  logger = console.info,
) {
  await addSingleDomainAlias(domain, logger);

  for (const subdomain of subdomains) {
    const fullSubdomain = `${subdomain}.${domain}`;
    await addSingleDomainAlias(fullSubdomain, logger);
  }
}
